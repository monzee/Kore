package org.xbmc.kore.utils;

import android.support.annotation.NonNull;

/**
 * Use {@link Either} or {@link Result} instead.
 *
 * I'll be using the task tests as basis for the Either tests so this will stay
 * here until I get to writing those tests.
 */
@Deprecated
public interface Task<T> {

    /**
     * Starts the computation, invokes a procedure when done.
     *
     * Tasks are lazy; instantiating a task or returning one from a method does
     * not perform any work. This method has to be called with a continuation
     * in order to actually start working.
     *
     * The procedure may be called any number of times, but it's usually once
     * or never. A task that doesn't invoke its {@link OnFinish} is considered
     * a failed task.
     *
     * @param then The consumer of the value being computed.
     */
    void start(@NonNull OnFinish<? super T> then);

    /**
     * A procedure that awaits a value.
     *
     * Also called "continuation" elsewhere. One task corresponds to exactly
     * one continuation. A task is considered to be "successful" when it calls
     * its continuation, otherwise it has "failed".
     *
     * There is no way to recover from a failure if the task simply ignores
     * its continuation. In such a case, it is assumed that the task instead
     * has called an error reporting or handling routine instead of the
     * continuation.
     *
     * If it is required for the system to defer the error handling to the
     * highest/outermost caller, then 1) the continuation must always be called
     * by the task even if it has failed and 2) the error condition must be
     * encoded in the type T of the task/continuation. An example would be to
     * use a Task[Option[T]] type instead of just Task[T]. An Option[T] will
     * always be passed to the continuation and the continuation can then
     * introspect the Option to decide how to proceed.
     *
     * No such type is provided here. It is up to the clients to code them up
     * for their use case.
     *
     * @param <T> The type of the value generated by a task.
     */
    interface OnFinish<T> {
        void got(T result);
    }

    /**
     * A function that produces a task from a value.
     *
     * Used for linking a task that depends on the value produced by another
     * task in a {@link Sequence}.
     *
     * @param <T> The value to derive a task from.
     * @param <U> The type of the derived task.
     */
    interface Bind<T, U> {
        Task<? extends U> from(T value);
    }

    /**
     * A wrapper for {@link Task} instances to allow chaining into other tasks
     * after one has completed successfully.
     *
     * @param <T> The type of the wrapped task.
     */
    class Sequence<T> implements Task<T> {

        /**
         * Static factory to prevent nesting of Sequence instances.
         *
         * @param task Task to wrap
         * @param <T> Its type
         * @return a Sequence instance.
         */
        public static <T> Sequence<T> of(Task<T> task) {
            if (task instanceof Sequence) {
                return (Sequence<T>) task;
            }
            return new Sequence<>(task);
        }

        private final Task<T> task;

        private Sequence(Task<T> task) {
            this.task = task;
        }

        /**
         * Generates a new task using the value produced by this task and
         * executes it.
         *
         * Remember that tasks are lazy. No task is run or even generated at the
         * time this method is called. The factory will only be called when
         * {@link #start(OnFinish)} is called and every Sequence task leading
         * to this completes successfully.
         *
         * @param next The factory for the next task
         * @param <U> The type of the next task
         * @return a task that composes this task and the next.
         */
        public <U> Sequence<U> then(final Bind<? super T, U> next) {
            return new Sequence<>(new Task<U>() {
                @Override
                public void start(@NonNull final OnFinish<? super U> then) {
                    Sequence.this.start(new OnFinish<T>() {
                        @Override
                        public void got(T result) {
                            next.from(result).start(then);
                        }
                    });
                }
            });
        }

        /**
         * Adds a new task to the chain ignoring the previous value generated.
         *
         * Use this when you do not need the value of the previous step, only
         * the fact that it was successful.
         *
         * @param next The next task
         * @param <U> Its type
         * @return a task that composes this task and the next.
         */
        public <U> Sequence<U> then(final Task<U> next) {
            return then(new Bind<T, U>() {
                @Override
                public Task<? extends U> from(T ignored) {
                    return next;
                }
            });
        }

        @Override
        public void start(@NonNull OnFinish<? super T> action) {
            task.start(action);
        }
    }

    /**
     * Static class for {@link Task} factories.
     */
    final class Just {

        /**
         * Turns a value into a task that produces the same value.
         *
         * @param result The value to wrap
         * @param <T> Its type
         * @return a task that may be passed to a {@link Sequence} or returned
         * by a {@link Bind}.
         */
        public static <T> Task<T> some(final T result) {
            return new Task<T>() {
                @Override
                public void start(@NonNull OnFinish<? super T> then) {
                    then.got(result);
                }
            };
        }

        /**
         * Produces a failed task.
         *
         * If passed to {@link Sequence#then(Task)} or returned by a
         * {@link Bind} passed to {@link Sequence#then(Bind)}, the subsequent
         * tasks in the sequence will not be invoked.
         *
         * @param <T> The success type of the task.
         * @return a failed task.
         */
        public static <T> Task<T> none() {
            return new Task<T>() {
                @Override
                public void start(@NonNull OnFinish<? super T> then) {
                }
            };
        }

        private Just() {
        }
    }

}
